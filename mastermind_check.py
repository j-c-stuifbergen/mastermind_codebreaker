# -*- coding: utf-8 -*-
"""mastermind_check.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/j-c-stuifbergen/mastermind_codebreaker/blob/main/mastermind_check.ipynb
"""

(code,OK_position, OK_partial) = ("code","match_position","match_partial (only color)")
 
def compare_codes(code1, code2):
  if len(code1)!=len(code2):
    raise Exception("codes of unequal length: "+str(code1) +str(code2))
  match_positions = 0
  for i in range(len(code1)):
    if code1[i]==code2[i]:
      match_positions +=1
  match_colors = 0
  for j in range(len(colors)):
    match_colors += min(code1.count(j),code2.count(j))
  return (match_positions, match_colors-match_positions)
  
def compare_scores(code1, code2, match_positions, match_partial):
  return (match_positions, match_partial)==compare_codes(code1, code2)
# generate all combinations
 
def filter_code(codes, testcode, match_positions, match_partial):
  counter = 0
  for i in range(len(codes)):
    if (match_positions, match_partial)==compare_codes(codes[i], testcode):
      codes[counter]=codes[i]
      # print (codes[counter])
      counter+=1
  if 0==counter:
    codes =[]
  return codes[:counter]
 
def filter_codes(codes, tests, show_size=20):
  for i in range(len(tests)):
    lenBefore = len(codes)
    codes = filter_code(codes, tests[i][code],tests[i][OK_position], \
                        tests[i][OK_partial])
    if 0<show_size:
      print("_____ test "+str(i)+": ")
      print(str(tests[i][code])+" "+code_string(colors, tests[i][code])+ \
        score_string(tests[i][OK_position],tests[i][OK_partial]))
      print("options left: "+str(len(codes))+" (eliminated: "+str(lenBefore - len(codes))+")")
      if len(codes)<=show_size:
        print_codes(colors, codes)
      else:
        print("(I won't show all those options...)")
  return codes
 
def create_codes(colors, code_size):
  col_indexes = []
  for i in range (code_size):
    col_indexes.append(int(0))
 
  codes = [] # [[]for i in range(code_size**len(colors)) ] 
  counter = 0
  position = 0
          
  while position < code_size:
    codes.append([])
    codes[counter]=[col_indexes[k] for k in range(code_size)]
    counter +=1
    col_indexes[position]+=1
    if len(colors)==col_indexes[position]:
      # perform carry
      while position < code_size and len(colors)==col_indexes[position]:
        col_indexes[position]=0
        position+=1
        if position < code_size:
          col_indexes[position]+=1
      # reset position
      if position < code_size:
        position = 0
  return codes
 
def code_string(colors, code):
  result = ""
  for k in range(len(code)):
      result += colors[code[k]]+" "
  return result
 
def score_string(score_pos, score_col):
  return " "+"*" * score_pos+"-"*score_col+ " "
  
def print_codes(colors, codes):
  for j in range(len(codes)):
    print(str(codes[j])+" "+code_string(colors, codes[j]))
 
def print_check(colors, codes, tests):
  for j in range(len(codes)):
    for k in range (len(tests)):
      (score_pos, score_col) = compare_codes(codes[j], tests[k][code])
      score_str = score_string(score_pos, score_col)
      print(str(codes[j])+" "+code_string(colors, codes[j])+score_str+code_string(colors,tests[k][code]))
 
def format_code(colors, code_str):
  color_list = code_str.replace(","," ").split()
  color_indexes = []
  for j in range(len(color_list)):
    color_indexes.append(colors.index(color_list[j]))
  return [colors.index(color_list[j]) for j in range(len(color_list))]
 
def str_test_struct(colors, test):
  return code_string(colors, test[code])+score_string(test[OK_position],test[OK_partial])

def format_test(colors, test_str, score_pos=0, score_part=0):
  return { code: format_code(colors,test_str), OK_position: score_pos, OK_partial: score_part}

def str_tests(colors, tests):
  result = ""
  for t in tests:
    result += str_test_struct(colors,t)+"\n"
  return result

(blue, red, green, yellow, marron, orange, black, white) = \
        ("blu", "red", "gre", "yel", "mar", "ora", "blk", "wht")
# colors = ["ul", "re", "gr", "ye", "pu", "or", "ma", "wh", "bk"]
 
colors = [blue, red, green, yellow, marron, orange, black, white]

codes = create_codes(colors, 6)
print("len codes = "+str(len(codes)))

# remove invalid combinations
# show results

print("filtered codes")
tests = []
tests.append(format_test(colors,"wht blk blk blk blk wht",1,1))
tests.append(format_test(colors,"wht gre gre blu blu blu",0,3))
tests.append(format_test(colors,"red red red ora ora wht",0,1))

tests.append(format_test(colors,"blu blu wht mar mar mar",1,2))
tests.append(format_test(colors,"blu mar wht blk gre blu",1,4))
tests.append(format_test(colors,"blk blu wht gre yel yel",1,4))

tests.append(format_test(colors,"yel gre blk mar blu wht",0,6))
tests.append(format_test(colors,"wht yel mar blu blk gre",2,4))
tests.append(format_test(colors,"gre blu yel blk mar wht",0,6))

codes = filter_codes(codes, tests)

# this requires less storage, because the tests are performed when there are too many combinations.
def create_limited_codes(colors, code_size, tests, countMax = 1):
  col_indexes = []
  for i in range (code_size):
    col_indexes.append(int(0))

  codes = [] # [[]for i in range(code_size**len(colors)) ] 
  counter = 0
  testCounter = 0
  position = 0
  eliminations = [0 for i in range(len(tests))]
  while position < code_size:
    counter+=1
    codes.append([])
    codes[-1]=[col_indexes[k] for k in range(code_size)]
    col_indexes[position]+=1
    if len(colors)==col_indexes[position]:
      # perform carry
      while position < code_size and len(colors)==col_indexes[position]:
        col_indexes[position]=0
        position+=1
        if position < code_size:
          col_indexes[position]+=1
      # reset position
      if position < code_size:
        position = 0
     
    # use some test results, to limit the list
    lastCode = codes[-1:]
    
    for i in range(testCounter):
      lastCode = filter_code(lastCode, tests[i][code],tests[i][OK_position], \
                        tests[i][OK_partial])
      if 0==len(lastCode): # pattern is rejected
        codes=codes[0:-1]
        eliminations[i] +=1
        break
    while countMax < len(codes) and testCounter < len(tests):
      # add a test
      lenBefore = len(codes)
      codes = filter_code(codes, tests[testCounter][code], \
                        tests[testCounter][OK_position], \
                        tests[testCounter][OK_partial])
      eliminations[testCounter]=lenBefore-len(codes)
      testCounter +=1
  return (codes, testCounter, eliminations)

nPositions = 6
(codes, nTest, eliminations) = create_limited_codes(colors, nPositions, tests,50)

print("I filtered by "+str(nTest)+" tests")

remaining = len(colors)**nPositions
for i in range(nTest):
  remaining -= eliminations[i]
  print(str(i+1)+": remaining "+str(remaining)+", eliminated "+str(eliminations[i])+" by "+code_string(colors,tests[i][code])+score_string(tests[i][OK_position],tests[i][OK_partial]))


print("\nremaining codes")
print_codes(colors, codes)

print("\nremaining tests")
test_remaining = tests[nTest:]
print(str_tests(colors, test_remaining))
print("result:")
codes = filter_codes(codes, test_remaining)


print("ready")